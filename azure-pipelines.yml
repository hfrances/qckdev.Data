###############################
### Template Version: 3.0.0 ###
### Author: hfrances        ###
### Date: 06/07/2022        ###
###############################

trigger:
  - master
  - main
  - staging
  - azure-pipelines

pool:
  vmImage: 'windows-2019'

parameters:
  - name: Deploy
    type: string
    values:
      - auto
      - true
      - false
    default: false
  - name: Analyze
    type: string
    values:
      - disabled
      - auto
      - true
      - false
    default: auto

variables:
  - name: BuildParameters.RestoreBuildProjects
    value: '**/*.sln'
  - name: BuildParameters.Solution
    value: '*.sln'
  - name: BuildParameters.TestProjects
    value: '**/*Test.??proj'
  - name: BuildParameters.ProjectKey
    value: $(Build.DefinitionName)
  - name: BuildParameters.ProjectName
    value: $(BuildParameters.ProjectKey)
  - name: BuildParameters.OutputFile
    value: ''
  - name: BuildConfiguration
    value: 'Release'
  - name: Deploy
    value: 'disabled' # Deploy manually in Nuget.org because of net35 and net40 frameworks. #${{ parameters.Deploy }}
  - name: PublishEnabled
    value: $[or(eq(variables.Deploy, 'true'), and(eq(variables.Deploy, 'auto'), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/main'))))]
  - ${{ if ne(parameters.Analyze, 'disabled') }} :
    - name: Analyze
      value: ${{ parameters.Analyze }}
    - name: SonarQubeEnabled
      value: $[or(eq(variables.Analyze, 'true'), and(eq(variables.Analyze, 'auto'), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/staging'))))]
  - name: SupportedFrameworks
    value: "9.0;8.0;7.0;6.0;5.0;3.1"

jobs:
  - job: Build
    steps:
      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
            $path = '$(Build.ArtifactStagingDirectory)/drop';
            if (!(Test-Path $path)) {
              New-Item -itemType Directory -Path '$(Build.ArtifactStagingDirectory)' -Name 'drop';
            }
        displayName: Create 'drop' folder

      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
              $path = '$(BuildParameters.Solution)';

              # Find solution file.
              $solution = (Get-Item $path);
              if ($null -eq $solution) {
                write-error 'Solution file not found: $path';
              }
              else {
                # Get first project in the solution. That is the main project.
                $content = (Get-Content $solution);
                $pattern = '(?m)Project\(.*\)\s?=\s?"(?<ProjectName>.*)",\s?"(?<ProjectPath>.*)",\s?.*"';
                $projects = $content | Select-String $pattern -AllMatches;

                if ($projects -and $projects.Matches.Count -gt 0) {
                  $projectPath = $projects.Matches[0].Groups['ProjectPath'].Value;
                  $projectFile = Join-Path $solution.Directory $projectPath;
                  $file = (Get-Item $projectFile);

                  if ($null -eq $file) {
                    write-error 'Project file not found: $projectFile';
                  }
                  else {
                    write-output $($file.FullName);
                    write-output "##vso[task.setvariable variable=MainProject.FullName]$($file.FullName)";
                  }
                }
              }
        displayName: Get main project from Solution

      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
            $file = (Get-Item '$(MainProject.FullName)');

            if ($null -eq $file) {
              write-error 'Project file not found: $(MainProject.FullName)';
            }
            else {
              # Get package name
              $packageName = $file.BaseName?.ToLower();
              write-output "Package name: $packageName";
              write-output "##vso[task.setvariable variable=MainProject.PackageName]$packageName";

              $xml = [Xml] (Get-Content $file);

              # Set version
              $version = "$($xml.Project.PropertyGroup.Version)"?.Trim();
              write-output "Version: $version";
              write-output "##vso[task.setvariable variable=MainProject.Version]$version";

              # Set description
              $description = "$($xml.Project.PropertyGroup.Description)"?.Trim();
              write-output "Description: $description";
              write-output "##vso[task.setvariable variable=MainProject.Description]$description";
            }
        displayName: Get main project properties

      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
            $files = Get-ChildItem -Recurse -Filter *.??proj;
      
            write-output "Supported frameworks: $SupportedFrameworks"
            if ($files.Count -eq 0) {
              write-error 'No project files found in the specified directory';
            } else {
              $files | ForEach-Object {
                $file = $_;
                write-output "Processing file: $file";
      
                # Load the XML content of the project file
                $xml = [xml](Get-Content -Path $file.FullName);
      
                # Calculate target frameworks
                $frameworks = "$($xml.Project.PropertyGroup.TargetFrameworks)"?.Trim().Split(";");
                write-output "Target frameworks: $frameworks";
                $frameworks | ForEach-Object {
                  $version = [regex]::match($_, '(\d+\.\d+)').Value;
                  if ($version) {
                    write-output "##vso[task.setvariable variable=BuildParameters.TargetFramework_$version]$_";
                  }
                }
                write-output '';
              }
            }
        displayName: Calculate target frameworks


      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
            # https://regex101.com/r/XJjOGd/1
            $regex = '(?<version>(?<major>\d+)(?:.(?<minor>\d+))(?:.(?<patch>\d+))?(?:.(?<build>\d+))?)(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$';

            if ("$(MainProject.Version)" -match $regex) {
                $version = $matches['version'];
                $major = $matches['major'];
                $minor = $matches['minor'];
                $patch = if ($matches['patch']) { $matches['patch'] } else { 0 }
                $build = $matches['build'];

                if ($matches['prerelease']) {
                  # The version already has its own sufix.
                  $releaseVersion = "$(MainProject.Version)";
                  $dockerVersion = -join ($releaseVersion -split '[^a-zA-Z0-9-]');
                  $dockerAlias = $prerelease;
                }
                elseif ("$(Build.SourceBranch)" -in @('refs/heads/master', 'refs/heads/main')) {
                  # Master or main has tag "latest".
                  $releaseVersion = "$(MainProject.Version)";
                  $dockerVersion = $releaseVersion;
                  $dockerAlias = "latest";
                }
                elseif ("$(Build.SourceBranch)" -eq 'refs/heads/staging') {
                  # Staging has tag "alpha".
                  $releaseVersion = "$(MainProject.Version)-alpha+$(Build.BuildId)";
                  $dockerVersion = $releaseVersion;
                  $dockerAlias = "alpha";
                }
                else {
                  # Other branches have the branch name as tag.
                  $branchNameClean = -join ($sourceBranchName -split '[^a-zA-Z0-9]');
                  $releaseVersion = "$(MainProject.Version)+$branchNameClean-$(Build.BuildId)";
                  $dockerVersion = "$(MainProject.Version)-$branchNameClean_$(Build.BuildId)";
                  $dockerAlias = "$branchNameClean";
                }
                # Calculate AssemblyVersion
                $assemblyVersion = "$major.$minor.$patch.$(Build.BuildId)";
                # Set variables
                write-output "##vso[task.setvariable variable=BuildParameters.ReleaseVersion]$releaseVersion";
                write-output "##vso[task.setvariable variable=BuildParameters.ReleaseAlphaVersion]$releaseAlphaVersion";
                write-output "##vso[task.setvariable variable=BuildParameters.DockerVersion]$dockerVersion";
                write-output "##vso[task.setvariable variable=BuildParameters.DockerAlias]$dockerAlias";
                # Display variables
                write-output "Release version: $releaseVersion"
                write-output "Release assembly version: $releaseAssemblyVersion"
                write-output "Docker version: $dockerVersion"
                write-output "Docker alias: $dockerAlias"
            }
            else {
              write-error "Invalid version format for: $(MainProject.Version)";
            }
          workingDirectory: '$(Build.SourcesDirectory)'
        displayName: 'Set release version'
        condition: succeeded()

      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
            $version = "$(BuildParameters.ReleaseVersion)";

            if ($version) {
              $file = (Get-Item '$(MainProject.FullName)');
              $xml = [Xml] (Get-Content $file);
              $xml.Project.PropertyGroup.Version = $version;

              $xml.Save($file.FullName); 
              Write-Output "Version updated to $version";
            }
            else {
              write-warning "No version.";
            }
            write-warning "patata";
          workingDirectory: '$(Build.SourcesDirectory)'
        displayName: 'Set release version to project'
        condition: succeeded()

      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
            # Set package full name.
            $packageName = "$(MainProject.PackageName)";
            $version = "$(BuildParameters.ReleaseVersion)";
            if ($version) {
              $sufix = ".v$version";
            }
            else {
              $sufix = "";
            }
            write-output "Output filename: $packageName$sufix.tar.gz";
            write-output "##vso[task.setvariable variable=BuildParameters.OutputFile]$packageName$sufix.tar.gz";
          workingDirectory: '$(Build.SourcesDirectory)'
        displayName: 'Set output filename'

      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
            $var = (gci env:*).GetEnumerator() | Sort-Object Name
            $out = ""
            Foreach ($v in $var) {$out = $out + "`t{0,-28} = {1,-28}`n" -f $v.Name, $v.Value}
          
            $fileName = Join-Path "$env:BUILD_ARTIFACTSTAGINGDIRECTORY" "drop/variable-list.md"
            write-output "dump variables on $fileName"
            set-content $fileName $out
      
            write-output "##vso[task.addattachment type=Distributedtask.Core.Summary;name=Environment Variables;]$fileName" 
        displayName: 'Export variable list'
        condition: succeededOrFailed()

      - ${{ each framework in split(variables.SupportedFrameworks, ';') }}:
        - task: UseDotNet@2
          inputs:
            packageType: 'sdk'
            version: '${{ framework }}.x'
            includePreviewVersions: false
          displayName: 'UseDotNet ${{ framework }}'
          condition: ne(variables['BuildParameters.TargetFramework_${{framework}}'], '')

      - task: DotNetCoreCLI@2
        displayName: Restore
        inputs:
          command: 'restore'
          projects: '**/*.??proj'
     
      - ${{ if ne(parameters.Analyze, 'disabled') }} :
        - task: SonarCloudPrepare@1
          inputs:
            SonarCloud: 'SonarCloud'
            organization: 'hfrances-github'
            scannerMode: 'MSBuild'
            projectKey: '$(BuildParameters.ProjectKey)'
            projectName: '$(BuildParameters.ProjectName)'
            projectVersion: '$(MainProject.Version)'
            extraProperties: |
              # Additional properties that will be passed to the scanner, 
              # Put one key=value per line, example:
              sonar.exclusions=**/obj/**,**/*.dll
              sonar.cs.opencover.reportsPaths=**/*.opencover.xml
              sonar.cs.cobertura.reportsPaths=**/*.cobertura.xml
              sonar.cs.vscoveragexml.reportsPaths=**/*.coveragexml
              sonar.cs.dotcover.reportsPaths=**/*.html
              sonar.cs.vstest.reportsPaths=$(Agent.TempDirectory)/*.trx
          condition: eq(variables.SonarQubeEnabled, 'true')

      - task: DotNetCoreCLI@2
        displayName: Build
        inputs:
          projects: '$(BuildParameters.RestoreBuildProjects)'
          arguments: '--configuration $(BuildConfiguration)'

      - task: DotNetCoreCLI@2
        displayName: 'Test + Coverage'
        inputs:
          command: test
          projects: '$(BuildParameters.TestProjects)'
          arguments: '--configuration $(BuildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=opencover /p:Exclude="[*Tests]*" /p:CoverletOutput="$(Build.SourcesDirectory)/TestResults/"'

      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
            $path = '$(BuildParameters.TestProjects)'
            $directoryInfo = Get-ChildItem "$path" | Measure-Object;
            $hasTests = $directoryInfo.Count -gt 0;
            write-output "##vso[task.setvariable variable=HasTests]$hasTests";
        displayName: 'Coverage: Check if there are test projects'

      - task: reportgenerator@4
        inputs:
          reports: '**/*.[Oo]pencover.xml;**/[Oo]pencover.xml;*.[Oo]pencover.xml;[Oo]pencover.xml'
          targetdir: '$(Build.SourcesDirectory)/TestResults/'
        continueOnError: true
        condition: eq(variables.HasTests, 'true')
        displayName: 'Coverage: Parse format'

      - task: PowerShell@2
        inputs:
          pwsh: true
          targetType: 'inline'
          script: |
            $path = @("**/*.[Cc]obertura.xml", "**/[Cc]obertura.xml", "*.[Cc]obertura.xml", "[Cc]obertura.xml");
            $files = @();
            $coverageResults = "";
            Get-Item $path;
            Get-Item $path | `
              Group-Object Directory | `
              ForEach-Object {
            	  $files += ($_.Group | Sort-Object LastWriteTime | Select-Object -First 1)
              };
            
            Write-Output "`nCollected coverage files:"
            $files.FullName;
            $files | ForEach-Object {
            	if ($coverageResults -ne "") {
            		$coverageResults +=";";
            	}
            	$coverageResults += $files.FullName;
              Copy-Item $_ $(Agent.TempDirectory); 
            }
            write-output "##vso[task.setvariable variable=CoverageResults]$coverageResults"
        condition: eq(variables.HasTests, 'true')
        displayName: 'Coverage: Collect files'
     
      - task: PublishCodeCoverageResults@1
        inputs:
          codeCoverageTool: 'Cobertura'
          summaryFileLocation: '$(CoverageResults)'
        continueOnError: true
        condition: eq(variables.HasTests, 'true')
        displayName: 'Coverage: Publish report'
     
      - ${{ if ne(parameters.Analyze, 'disabled') }} :
        - task: SonarCloudAnalyze@1
          condition: eq(variables.SonarQubeEnabled, 'true')
        - task: SonarCloudPublish@1
          inputs:
            pollingTimeoutSec: '300'
          condition: eq(variables.SonarQubeEnabled, 'true')

      - task: DotNetCoreCLI@2
        inputs:
          command: 'pack'
          packagesToPack: '**/*.??proj;!examples/**/*.??proj;!**/*.Test.??proj;!**/*.Test.*.??proj'
          packDirectory: '$(Build.ArtifactStagingDirectory)/build'
          nobuild: true
          versioningScheme: 'off'
        displayName: 'NuGet: Pack'

      - task: PublishBuildArtifacts@1
        displayName: 'Publish Artifact: drop'
        inputs:
          pathtoPublish: '$(Build.ArtifactStagingDirectory)/drop'
        condition: succeededOrFailed()
     
      - task: PublishPipelineArtifact@1
        displayName: 'Publish Artifact: build'
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/build'
          artifact: 'build'
    
      - task: NuGetCommand@2
        inputs:
          command: 'push'
          packagesToPush: '$(Build.ArtifactStagingDirectory)/**/*.nupkg;!$(Build.ArtifactStagingDirectory)/**/*.symbols.nupkg'
          nuGetFeedType: 'external'
          publishFeedCredentials: 'nuget.org'
        displayName: 'NuGet: Push'
        condition: eq(variables.PublishEnabled, 'true')

################################################################################################
# Version 2.1.0: Auto-detect main project, 
#                Allow disable SonarQube without comment lines.
#                Include name and version in package file name.
# Version 2.1.1: Fix 'Publish Artifact: build'
#                Add condition for 'Nuget: Push'
# Version 2.2.0: Add 'UseDotNet 6.0'
# Version 2.2.1: Fix 'Nuget pack'
# Version 3.0.0: Introduce SupportedFrameworks for multiple dotnet supports
################################################################################################
